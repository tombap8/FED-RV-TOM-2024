<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js Earth Sphere - Korea Marker, Natural Autorotate (교육용 주석)</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- Three.js 라이브러리 불러오기 (반드시 사용자 코드보다 먼저!) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    //=======================//
    // 1. Three.js 기본 세팅
    //=======================//

    // (1) Scene : 3D 오브젝트, 빛 등이 있는 무대
    const scene = new THREE.Scene();

    // (2) Camera : 3D 무대를 바라볼 시점(눈)
    const camera = new THREE.PerspectiveCamera(
      75, window.innerWidth / window.innerHeight, 0.1, 1000
    );

    // (3) Renderer : 3D 결과를 브라우저에 그림
    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    //=======================//
    // 2. 지구 텍스처 불러오기
    //=======================//
    const textureLoader = new THREE.TextureLoader();
    const earthTexture = textureLoader.load(
      'https://raw.githubusercontent.com/turban/webgl-earth/master/images/2_no_clouds_4k.jpg',
      render // 이미지가 로드되면 첫 렌더
    );

    //=======================//
    // 3. 지구본 만들기 + 자전축 그룹화
    //=======================//
    const geometry = new THREE.SphereGeometry(2, 64, 64);
    const material = new THREE.MeshPhongMaterial({
      map: earthTexture,
      shininess: 10
    });
    const earth = new THREE.Mesh(geometry, material);

    // (1) 자전축(23.5도 기울기) 위한 그룹
    const earthGroup = new THREE.Group();
    earthGroup.add(earth);
    scene.add(earthGroup);

    // (2) 자전축 기울기 (23.5도 = 실제 지구)
    const earthTilt = THREE.MathUtils.degToRad(23.5);
    earthGroup.rotation.x = earthTilt;

    //=======================//
    // 4. 빛(조명) 추가
    //=======================//
    const ambient = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambient);

    const directional = new THREE.DirectionalLight(0xffffff, 0.8);
    directional.position.set(5, 3, 5);
    scene.add(directional);

    camera.position.z = 6;

    //=======================//
    // 5. 회전/상태 변수 및 자동회전 복귀용 변수
    //=======================//
    let isUserInteracting = false;   // 사용자가 드래그 중인지
    let lastPointerX = 0;
    let lastPointerY = 0;
    let targetRotationY = 0;         // 사용자의 최종 y(동서) 회전값
    let targetRotationX = 0;         // 사용자의 최종 x(상하) 회전값
    let autoRotate = true;           // 자동회전 상태
    let autoRotateTimeout = null;    // 자동회전 복귀 타이머
    let autorotateSpeed = 0.005;     // 자동 자전 속도 (값이 클수록 빠름)
    let autorotateY = 0;             // 자동회전 진행용 y값 (자동회전이 사용자의 마지막 경도에서 시작됨)

    // 자동회전 복귀 트윈 애니메이션 변수
    let resetAnimStart = null;
    let resetAnimDuration = 800; // ms (0.8초)
    let resetFromX = 0, resetFromY = 0;

    //=======================//
    // 6. 대한민국 서울 위치에 "Korea" 마커 표시
    //=======================//
    // (1) 서울 위도/경도 (약 37.5665N, 126.9780E)
    // (2) 위도/경도를 3D 구좌표로 변환하는 함수
    function latLngToVector3(lat, lng, radius) {
      // 위도, 경도(degree) → 라디안
      const phi = THREE.MathUtils.degToRad(90 - lat); // 위도는 90-값으로 변환
      const theta = THREE.MathUtils.degToRad(lng + 180); // 경도는 +180도
      // 구면좌표계 → 3D 좌표계로 변환
      return new THREE.Vector3(
        -radius * Math.sin(phi) * Math.cos(theta), // x
         radius * Math.cos(phi),                   // y
         radius * Math.sin(phi) * Math.sin(theta)  // z
      );
    }

    // (3) 마커(작은 빨간색 구) 생성
    const markerGeometry = new THREE.SphereGeometry(0.04, 12, 12);
    const markerMaterial = new THREE.MeshBasicMaterial({color: 0xff3333});
    const koreaMarker = new THREE.Mesh(markerGeometry, markerMaterial);

    // (4) 마커 위치 계산 (구 반지름=2, 표면 약간 위에)
    const koreaPos = latLngToVector3(37.5665, 126.9780, 2.02);
    koreaMarker.position.copy(koreaPos);

    // (5) "Korea" 텍스트 라벨 (CanvasTexture)
    function createLabelCanvas(text, fontSize = 32, color = "white", bgColor = "rgba(0,0,0,0.6)") {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = `bold ${fontSize}px sans-serif`;
      const textWidth = ctx.measureText(text).width;
      canvas.width = textWidth + 20;
      canvas.height = fontSize + 20;
      // 배경
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      // 텍스트
      ctx.fillStyle = color;
      ctx.textBaseline = 'top';
      ctx.font = `bold ${fontSize}px sans-serif`;
      ctx.fillText(text, 10, 10);
      return canvas;
    }

    const labelCanvas = createLabelCanvas("Korea", 28);
    const labelTexture = new THREE.CanvasTexture(labelCanvas);

    // 라벨을 평면(Plane) 메쉬로 만듦
    const labelMaterial = new THREE.SpriteMaterial({map: labelTexture, transparent: true});
    const labelSprite = new THREE.Sprite(labelMaterial);

    // 라벨 위치: 마커 바로 위에 (벡터 복사 후 y축 약간 더 올림)
    labelSprite.position.copy(koreaPos.clone().add(new THREE.Vector3(0, 0.12, 0)));
    labelSprite.scale.set(0.45, 0.16, 1); // 크기 조절

    // (6) earth(구) 자체에 마커와 라벨을 붙여서 항상 지구와 함께 회전하도록!
    earth.add(koreaMarker);
    earth.add(labelSprite);

    //=======================//
    // 7. 사용자 입력(드래그) 처리
    //=======================//
    function onPointerDown(event) {
      isUserInteracting = true;
      autoRotate = false;

      const pointer = event.touches ? event.touches[0] : event;
      lastPointerX = pointer.clientX;
      lastPointerY = pointer.clientY;

      if (autoRotateTimeout) {
        clearTimeout(autoRotateTimeout);
        autoRotateTimeout = null;
      }
    }

    function onPointerMove(event) {
      if (!isUserInteracting) return;
      const pointer = event.touches ? event.touches[0] : event;
      const deltaX = pointer.clientX - lastPointerX;
      const deltaY = pointer.clientY - lastPointerY;

      targetRotationY += deltaX * 0.01;
      targetRotationX += deltaY * 0.01;
      targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));

      lastPointerX = pointer.clientX;
      lastPointerY = pointer.clientY;
    }

    function onPointerUp() {
      isUserInteracting = false;

      // 5초 후 자동회전 복귀 (사용자가 돌려놓은 각도에서 자연스럽게 시작)
      if (autoRotateTimeout) clearTimeout(autoRotateTimeout);
      autoRotateTimeout = setTimeout(() => {
        // 복귀 애니메이션 시작 (현재 각도에서 0,0으로 천천히 이동)
        resetAnimStart = performance.now();
        resetFromX = targetRotationX;
        resetFromY = targetRotationY;
        autoRotateTimeout = null;
      }, 5000);
    }

    renderer.domElement.addEventListener('mousedown', onPointerDown, false);
    renderer.domElement.addEventListener('mousemove', onPointerMove, false);
    renderer.domElement.addEventListener('mouseup', onPointerUp, false);
    renderer.domElement.addEventListener('mouseleave', onPointerUp, false);

    renderer.domElement.addEventListener('touchstart', onPointerDown, false);
    renderer.domElement.addEventListener('touchmove', onPointerMove, false);
    renderer.domElement.addEventListener('touchend', onPointerUp, false);

    //=======================//
    // 8. 애니메이션 루프
    //=======================//
    function animate() {
      requestAnimationFrame(animate);

      // (1) 드래그 후 5초 뒤 복귀 애니메이션: 정립 자세로 부드럽게 복귀
      if (resetAnimStart !== null) {
        let t = (performance.now() - resetAnimStart) / resetAnimDuration;
        if (t >= 1) {
          t = 1;
          resetAnimStart = null;
          // **자동회전 시작 위치를 사용자가 마지막으로 놓은 경도에서 이어가게 한다**
          autorotateY = resetFromY; // 바로 이 부분이 핵심!
          targetRotationX = 0;
          targetRotationY = 0;
          autoRotate = true;
        } else {
          // easeOutCubic(감속) 보간
          t = 1 - Math.pow(1 - t, 3);
          targetRotationX = resetFromX * (1 - t);
          targetRotationY = resetFromY * (1 - t);
        }
        // 복귀 중에는 사용자가 돌린 각도로 적용
        earth.rotation.y = earth.rotation.y;
        earthGroup.rotation.x = earthTilt + targetRotationX;
      }
      // (2) 자동회전: 마지막 사용자가 돌려놓은 경도(autorotateY)에서부터 계속 진행
      else if (autoRotate) {
        earthGroup.rotation.x = earthTilt;
        earth.rotation.y = autorotateY; // 항상 autorotateY에서 시작
        autorotateY += autorotateSpeed; // 속도조절: autorotateSpeed(기본 0.005)
      }
      // (3) 사용자가 드래그 중: 자유 회전
      else {
        earth.rotation.y = targetRotationY;
        earthGroup.rotation.x = earthTilt + targetRotationX;
      }

      render();
    }

    function render() {
      renderer.render(scene, camera);
    }

    animate();

    //=======================//
    // 9. 반응형(창크기변경)
    //=======================//
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    //=======================//
    // [교육용 요약]
    //=======================//
    // 1. Scene, Camera, Renderer로 Three.js 기본 구조를 익히세요.
    // 2. SphereGeometry로 구를 만들고, MeshPhongMaterial로 표면에 텍스처(지구 이미지)를 입힙니다.
    // 3. 실제 지구처럼 23.5도 기울어진 자전축을 earthGroup으로 구현했습니다.
    // 4. 마우스/터치로 자유롭게 회전시키고, 손을 떼면 5초 후 북극이 위인 정립자세로 부드럽게 복귀합니다.
    // 5. 복귀 후에는 사용자가 마지막으로 돌려놓은 경도(동서 위치)에서부터 자전축만 따라 자동회전합니다.
    //    (자동회전의 시작 위치가 바로 마지막 사용자의 경도에서 이어집니다!)
    // 6. 서울(대한민국) 위치에 "Korea" 마커(빨간점)와 텍스트가 표시됩니다.
    //    - latLngToVector3() 함수로 위경도를 구좌표로 변환하여 마커 위치를 잡습니다.
    //    - label은 CanvasTexture로 동적으로 생성하여 Sprite로 표시했습니다.
    // 7. 자동회전 속도는 autorotateSpeed 값(기본 0.005)로 조절 가능합니다.
    // 8. Three.js 공식 문서를 참고하며 실험해보세요! https://threejs.org/
  </script>
</body>
</html>